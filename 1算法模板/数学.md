# 数学
## 随机数生成器
常用于异或哈希
```cpp
//#include<random>
int rand() {
	int min=0,max=1e9;
    static std::mt19937_64 rng(std::random_device{}());
    return std::uniform_int_distribution<int>(min, max)(rng);
}
```
## 取整
```cpp
//对a/b取整
a/b //向下取整
(a+b-1)/b //向上取整
(a+b/2)/b //四舍五入
```
## 快速幂
```cpp
//不乘1LL见祖宗
int qpow(int m, int k)
{
    int res = 1 % mod, t = m;
    while (k)
    {
        if (k & 1)
            res = 1LL*res * t % mod;
        t = 1LL*t * t % mod;
        k >>= 1;
    }
    return res;
}
```
## 快速组合数/排列数（模运算）
对称性：$C_n^k=C_n^{k-1}$
递推式：$C_n^k+C_n^k-1=C_n+1^k$
系数和：$\sum_{i=0}^n C_n^i=2^n$

```cpp  
class Comb{
    vector<int> f;
    vector<int> g;
    const int mod =1e9+7;
    int qpow(int m, int k)
    {
        int res = 1 % mod, t = m;
        while (k)
        {
            if (k & 1)
                res = 1LL*res * t % mod;
            t = 1LL*t * t % mod;
            k >>= 1;
        }
        return res;
    }
public:
    Comb(int n) : f(n + 1), g(n + 1)
    {
        f[0]=1;
        for (int i = 1; i <= n; i++)
            f[i] = 1LL*f[i - 1] * i % mod;
        g[n]= qpow(f[n], mod - 2);
        for(int i=n;i;i--){
            g[i - 1] = 1LL * g[i] * i % mod;
        }
    }
    int C(int n, int m)
    {
        if (n < m || m < 0)
            return 0;
        return 1LL*f[n] * g[m]%mod * g[n - m] % mod;
    }
    int A(int n, int m)
    {
        if (n < m || m < 0)
            return 0;
        return f[n] * g[n - m] % mod;
    }
};
Comb cmb(10000);
```
## 质数判定

```cpp
bool isprime(int n){//O（sqrt(N)）
	if(n<2)return false;
	for(int i=2;i<=n/i;i++){
		if(n%i==0)return false;
	}
	return true;
}
```
## 分解质因数

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

## 欧拉筛
### 朴素欧拉筛
```cpp
class sieve{
	vector<bool>st;
	vector<int> primes;
	public:
	sieve(int n){
		st.assign(n + 1, false);
		for (int i = 2;i<=n;i++){
			if(!st[i])primes.push_back(i);
			for (int j = 0; primes[j] <= n / i;j++){
				st[primes[j] * i] = true;
				if(i%primes[j]==0)
					break;
				}
		}
	}
	int find(int x){//找到大于等于x的第一个质数
		return *lower_bound(primes.begin(), primes.end(),x);
	}
};
sieve sv(1e6);
```
### SPF欧拉筛（支持快速质因数分解`O(logn)`，快速质数判断`O(1)`)
```cpp
struct sieve
{
    vector<int> spf;    
    vector<int> primes; 
    int n;             
    sieve(int _n) : n(_n){
        spf.resize(n + 1, 0); 
        spf[1] = 1;
        for (int i = 2; i <= n; i++){
            if (spf[i] == 0){
                spf[i] = i; // 质数的最小质因子是它本身
                primes.push_back(i);
            }
            for (int p : primes){
                if (p > spf[i] || 1LL * i * p > n)
                    break;
                spf[i * p] = p; // 标记最小质因子
            }
        }
    }
    // 质因数分解O(logn)
    void divide(int n){
        while (n > 1){
            int p = spf[n], count = 0;
            while (spf[n] == p)
                count++, n /= p;
            // 在这里分解出了每一个质因数p^count
        }
    }
    bool isprime(int x){
	    return spf[x]==x;
    }
    int find(int x){//找到大于等于x的第一个质数
		return *lower_bound(primes.begin(), primes.end(),x);
	}
};
```
## 最大公约数 最小公倍数
```cpp
int gcd(int a,int b){//返回a和b的最大公约数 O(logn)
	return b ? gcd(b, a % b) : a;
}
int gcd(int a, int b)//位运算优化快速gcd
{
	if(b) while(b ^= a ^= b ^= a %= b);
	return a;
}
int lcm(int a, int b){
	return a / gcd(a, b)*b;//警示后人:先除再乘防止越界
}
```
## 拓展欧几里得算法
```cpp
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b % x;
    return d;
}
```
## 乘法逆元
```cpp
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b % x;
    return d;
}
int inv(int a,int m){
    int x,y;
    int g = exgcd(a, m, x, y);
    if(g!=1)
        return -1;
    else
        return (x % m + m) % m;
}
```