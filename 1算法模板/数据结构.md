# 数据结构
## 单调队列
```cpp
//双端队列
deque<int>q
for(int i=0;i<n;i++){//队列中存的是下标
	if(q.size()&&i-k+1>q.front())q.pop_front();//判断队头是否已经滑出窗口；
	while(q.size()&&a[q.back()]>=a[i])tt--;//维护队列单调性 如果队尾大于要入列的元素，弹出队尾//双端队列
	q.push_back(i);新元素入队
}
```
## 单调栈
```cpp
//找到每一个元素在入栈方向上第一个满足对该元素的单调条件的元素
stack<int> stk;
for(int i=0;i<n;i++){
	while(stk.size()&&a[stk.back()]>=a[i])stk.pop()//出栈 第一个小于等于a[stk.back()]的数是a[i]
	stk.push(i);//入栈//存的是下标
}
```
## 树状数组
* 数据需要具有==区间可加性与区间可减性==
* 树状数组作为桶使用时，可以统计`一个数组中，i前面比a[i]小的元素数量`
* 树状数组的优点在于其可修改性，把一个离线问题改变某些数据的排列方式就可以得到某种有序性，随即可以转化成在线问题，而求在这个在线过程中某些值的累积，可以通过树状数组求解
* 要实现区间修改+单点查询，就在a的差分数组上建树状数组
* 要实现区间修改+区间查询，用线段树即可
```cpp
template <typename T>
class Fenwick
{
    vector<T> c;
    int n;
public:
    Fenwick(int _n)//树状数组大小为[1,n]
    { // 用数组大小初始化
        n = _n;
        c.assign(n + 1, 0);
    }
    Fenwick(vector<T> &a) // 用数组初始化
    {
        n = a.size() - 1;
        vector<T> pre(n + 1, 0);
        c.assign(n + 1, 0);
        for (int i = 1; i <= n; i++)
        {
            pre[i] = pre[i - 1] + a[i];
            c[i] = pre[i] - pre[i - (i & -i)];
        }
    }
    T sum(int x)
    { // 求x位置的前缀和
        T res{};
        for (int i = x; i; i -= i & -i)
        {
            res += c[i];
        }
        return res;
    }
    void add(int x, const T &y)
    { // 在x位置上加上y
        for (int i = x; i <= n; i += i & -i)
            c[i] += y;
    }
    T range(int l, int r)
    { // 计算[l,r]的区间和
        return sum(r) - sum(l - 1);
    }
    int select(const T &k)//找到最大的下标x,使得sum(x)<=k,维护频次信息时，select(k)+1表示第k大的数，复杂度O(logn) 比在sum上二分O(log^2 n)更快,比对顶堆常数更小
    {
        int x = 0;
        T cur{};
        for (int i = 1 << __lg(n); i; i /= 2)
            if (x + i <= n && cur + c[x + i] <= k)
                x += i,cur+=c[x];
        return x;
    }
};
```

## ST表
要求RMQ的操作函数具有==区间可加性==，如min，max，gcd，位操作（&，^，|），修改操作函数的时候记得修改ans的初始值
初始化时间复杂度为`O(n*logn)`,查询的复杂度为`O(1)`

```cpp
class ST{
    vector<vector<int>> f;
    public:
    ST(const vector<int>& a){
        int n = a.size() - 1;
        f.assign(n + 1, vector<int>(int(log2(n)) + 2));
        for (int i = 1; i <= n; i++)
            f[i][0] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 1; i + (1 << j) - 1 <= n; i++)
                f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);//op
    }
    int RMQ(int l, int r)
    {
        int L = r - l + 1, ans = -0x3f3f3f3f;//op
        for (int i = 0, j = l; (1 << i) <= L; i++)
        {
            if ((L >> i) & 1)
            {
                ans = max(ans, f[j][i]);//op
                j += (1 << i);
            }
        }
        return ans;
    }
};
```
## 线段树
#### Info线段树
```cpp
// 自定义数据类型线段树
struct tag
{
    LL add = 0;
    tag(LL a = 0) : add(a) {}
};

struct info
{
    LL sum = 0;
    int len = 1; // 区间长度
    info() {}
    info(LL x) : sum(x) {}
    // 应用标记：区间加
    info apply(tag t, int new_len) const
    {
        info res = *this;
        res.sum += t.add * new_len; // 区间和更新
        return res;
    }
};
// 标记合并
tag operator+(const tag &a, const tag &b)
{
    return tag(a.add + b.add); // 加法合并
}
// 区间合并
info operator+(const info &a, const info &b)
{
    info res;
    res.sum = a.sum + b.sum;
    res.len = a.len + b.len; // 维护区间长度
    return res;
}
class stree
{
    vector<info> w;   // 存储区间信息
    vector<tag> lazy; // 存储延迟标记
    int n;
    // 应用标记到节点
    void maketag(int u, int len, const tag &t)
    {
        // 合并标记（需重载tag的+运算符）
        lazy[u] = lazy[u] + t;
        // 应用标记到区间信息（需实现info::apply方法）
        w[u] = w[u].apply(t, len);
    }

    // 标记下传
    void pushdown(int u, int L, int R)
    {
        if (lazy[u].add == 0)
            return;
        int M = (L + R) >> 1;
        maketag(u << 1, M - L + 1, lazy[u]); // 左子树
        maketag(u << 1 | 1, R - M, lazy[u]); // 右子树
        lazy[u] = tag();                     // 重置为空标记
    }
    // 合并子节点信息
    void pushup(int u)
    {
        w[u] = w[u << 1] + w[u << 1 | 1];
    }

    // 区间查询
    info query(int u, int L, int R, int l, int r)
    {
        if ((l <= L) && (R <= r))
        {
            return w[u];
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            return query(u << 1, L, M, l, r) + query(u << 1 | 1, M + 1, R, l, r);
        }
        else
        {
            return info(); // 返回空info（需默认构造函数）
        }
    }
    //单点修改（插入数据）
    void insert(int u, int L, int R, int p, const info &x)
    {
        if (L == R)
        {
            w[u] = x;
        }
        else
        {
            pushdown(u, L, R);
            int M = (L + R) >> 1;
            if (p <= M)
                insert(u << 1, L, M, p, x);
            else
                insert(u << 1 | 1, M + 1, R, p, x);
            pushup(u);
        }
    }
    //区间加
    void update(int u, int L, int R, int l, int r, const tag &x)
    {
        if ((l <= L) && (R <= r))
        {
            maketag(u, R - L + 1, x);
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            update(u << 1, L, M, l, r, x);
            update(u << 1 | 1, M + 1, R, l, r, x);
            pushup(u);
        }
    }

public:
    stree(int _n) : n(_n)
    {
        w.resize(4 * n + 1);
        lazy.resize(4 * n + 1);
    }
    // 单点查询接口
    info query(int p)
    {
        return query(1, 1, n, p,p);
    }
    // 区间查询接口
    info query(int l, int r)
    {
        return query(1, 1, n, l, r);
    }
    // 单点修改接口
    void insert(int p, const info &x)
    {
        insert(1, 1, n, p, x);
    }
    // 区间加法接口
    void update(int l, int r, const tag &x)
    {
        update(1, 1, n, l, r, x);
    }
};


```

## Tire字典树
```cpp
int son[N][26];//[N]结点的[26]儿子的下标
int cnt[N];//以[N]结尾的单词的数量
int idx;//树结点的编号
//下标是0的点，既是根结点，又是空结点
void insert(char str[]){
	int p=0;//当前在树的哪个位置
	for(int i=0;str[i];i++){
		int u = str[i]-'a';//映射
		if(!son[p][u])son[p][u]=++idx;//如果这个字母不在树上，创建结点
		p=son[p][u];//更新位置
	}
	cnt[p]++;
}
int query(char str[]){
	int p=0;
	for(int i=0;str[i];i++){
		int u=str[i]-'a';
		if(!son[p][u])return 0;
		p = son[p][u];
	}
	return cnt[p];
}
```
## KMP
```cpp
void get_Next(string s, int next[])	//这个函数对字符串s进行预处理得到next数组
{
	int j = 0;
	next[0] = 0;//初始化
	for(int i = 1; i<s.size(); i++){//i指针指向的是后缀末尾，j指针指向的是前缀末尾
		while(j>0&&s[i]!=s[j])	j = next[j-1];//前后缀不相同，去找j前一位的最长相等前后缀
		if(s[i]==s[j])	j++;//前后缀相同，j指针后移
		next[i] = j;//更新next数组
	}
}
int strSTR(string s, string t)	//是从s中找到t，如果存在返回t出现的位置，如果不存在返回-1
{
	if(t.size()==0)	return 0;
	get_Next(t, next);
	for(int i = 0,j = 0; i < s.size(); i++){
		while(j>0&&s[i]!= t[j])	j = next[j-1];	
		if(s[i]==t[j])	j++;
		if(j==t.size())	return i - t.size() + 1;
	}
	return -1;
}
```