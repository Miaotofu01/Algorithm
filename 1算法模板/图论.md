# 图论
## 常见子问题
### 判断图的连通性
常用于判断欧拉路径的存在
```cpp
bool check(const vector<vector<int>> &g){
    vector<bool> st(g.size(), false);
    queue<int> q;
    st[1] = true;
    int cnt = 1;
    q.push(1);
    while (q.size())
    {
        int u = q.front();
        q.pop();
        for (int v : g[u])
        {
            if (!st[v])
            {
                st[v] = true;
                cnt++;
                q.push(v);
            }
        }
    }
    return cnt == g.size() - 1;
}
```
## 树论
### 树的直径
```cpp
    vector<int> dis(n + 1); // 根到所有点的距离
    vector<int> fa(n + 1);  // dfs路径中所有点的前继
    int far=0;//每次dfs中根能到达的最远的点
    function<void(int, int)> dfs = [&](int u, int f) mutable -> void
    {
        fa[u] = f;
        if(dis[u]>dis[far])
            far = u;
        for(PII ne:g[u]){
            int v = ne.first, w = ne.second;
            if(v==f)
                continue;
            dis[v] = dis[u] + w;
            dfs(v, u);
        }
    };
    dis[1] = 0;
    dfs(1, 0);
    int A=far;
    dis[A]=0;
    dfs(A, 0);
    int B = far;
```
### 树的重心
```cpp
    vector<int> f(n + 1);//f[u]保存u的最大子树的大小
    vector<int> size(n + 1);//size[u]表示u这个子树的大小
    int center = 0;//求解的重心
    f[0] = INF;
    function<void(int, int)> getcenter = [&](int u, int fa) mutable -> void
    {
        size[u] = 1, f[u] = 0;
        for (int v:g[u])
        {
            if(v==fa)
                continue;
            getcenter(v, u);
            size[u]+=size[v];
            f[u] = max(f[u], size[v]);
        }
        f[u] = max(f[u], n - size[u]);
        if (f[u] < f[center] || f[u] == f[center] && u < center)
            center = u;
    };
    getcenter(1,0);
```
### 最近公共祖先（LCA）
#### 倍增算法（在线算法$O(logn)$)
```cpp
    int nbit = __lg(n);
    vector<int> dep(n + 1);
    vector<vector<int>> anc(n + 1, vector<int>(nbit + 1));
    function<void(int, int)> dfs = [&](int u, int f) mutable -> void
    {
        anc[u][0] = f;
        dep[u] = dep[f] + 1;
        for (int v : g[u])
        {
            if (v == f)
                continue;
            dfs(v, u);
        }
    };
    dfs(root, 0);
    // init anc
    for (int j = 1; j <= nbit; j++)
        for (int i = 1; i <= n; i++)
            anc[i][j] = anc[anc[i][j - 1]][j - 1];
    // LCA
    function<int(int, int)> LCA = [&](int u, int v) mutable -> int
    {
        if (dep[u] < dep[v])
            swap(u, v);
        for (int i = nbit; i >= 0; i--)
            if (dep[anc[u][i]] >= dep[v])
                u = anc[u][i];
        if (u == v)
            return u;
        for (int i = nbit; i >= 0; i--)
            if (anc[u][i] != anc[v][i])
                u = anc[u][i], v = anc[v][i];
        return anc[u][0];
    };
```
#### tarjan算法（离线算法$O(n+m)$）
（暂空）
### 树链剖分/重链剖分
```cpp
// 使用方法：
// 初始化：addedge后init(root)，可以修改MOD，MOD默认为2e9
// 方法：
// void upd(int x, int y, LL z)在x到y的路径上所有点权+z
// LL qry(int x, int y) 查询x到y路径上的点权和
// void updtree(int x, LL z) 把x子树的点权+z
// LL qrytree(int x)查询x子树的点权
// int lca(int u, int v)树链LCA
struct tag
{
    LL add = 0;
    tag(LL a = 0) : add(a) {}
};

struct info
{
    LL sum = 0;
    int len = 1; // 区间长度
    info() {}
    info(LL x) : sum(x) {}
    // 应用标记：区间加
    info apply(tag t, int new_len) const
    {
        info res = *this;
        res.sum = (res.sum + t.add * new_len % MOD) % MOD; // 区间和更新
        return res;
    }
};
// 标记合并
tag operator+(const tag &a, const tag &b)
{
    return tag((a.add + b.add) % MOD); // 加法合并
}
// 区间合并
info operator+(const info &a, const info &b)
{
    info res;
    res.sum = (a.sum + b.sum) % MOD;
    res.len = a.len + b.len; // 维护区间长度
    return res;
}

class HLD
{
    int n;
    vector<int> fa, wc, sz, top, dfn, rdfn, dep;
    vector<info> w;// 线段树数组
    vector<tag> lazy; 
    vector<vector<int>> g;

    int cur;

public:
    vector<int> p; // 点权数组
    // 初始化部分
    HLD(int _n) : n(_n),
                  fa(n + 1), wc(n + 1), sz(n + 1), top(n + 1),
                  dfn(n + 1), rdfn(n + 1), dep(n + 1), g(n + 1),
                  p(n + 1), w(4 * (n + 1)), lazy(4 * (n + 1)), cur(0) {}

    void addedge(int u, int v)
    {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    void init(int root = 1)
    {
        dfs1(root, 0);
        dfs2(root, root);
        build(1, 1, n);
    }

private:
    void dfs1(int u, int f)
    {
        sz[u] = 1;
        fa[u] = f;
        dep[u] = dep[f] + 1;
        wc[u] = 0;
        for (int v : g[u])
        {
            if (v == f)
                continue;
            dfs1(v, u);
            sz[u] += sz[v];
            if (sz[v] > sz[wc[u]])
                wc[u] = v;
        }
    }

    void dfs2(int u, int TOP)
    {
        dfn[u] = ++cur;
        rdfn[cur] = u;
        top[u] = TOP;
        if (wc[u])
        {
            dfs2(wc[u], TOP);
            for (int v : g[u])
            {
                if (v == fa[u] || v == wc[u])
                    continue;
                dfs2(v, v);
            }
        }
    }

public:
    // 树链LCA
    int lca(int u, int v)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] > dep[top[v]])
            {
                u = fa[top[u]];
            }
            else
            {
                v = fa[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    // 线段树部分
private:
    void build(int u, int L, int R)
    {
        lazy[u] = tag();
        if (L == R)
        {
            w[u] = info()+info(p[rdfn[L]]);
            return;
        }
        int M = (L + R) >> 1;
        build(u * 2, L, M);
        build(u * 2 + 1, M + 1, R);
        pushup(u);
    }

    void maketag(int u, int len, const tag &t)
    {
        // 合并标记（需重载tag的+运算符）
        lazy[u] = lazy[u] + t;
        // 应用标记到区间信息（需实现info::apply方法）
        w[u] = w[u].apply(t, len);
    }

    // 标记下传
    void pushdown(int u, int L, int R)
    {
        // 空标记检查（需tag支持==比较）
        if (lazy[u].add == 0)
            return;
        int M = (L + R) >> 1;
        maketag(u << 1, M - L + 1, lazy[u]); // 左子树
        maketag(u << 1 | 1, R - M, lazy[u]); // 右子树
        lazy[u] = tag();                     // 重置为空标记
    }

    // 合并子节点信息
    void pushup(int u)
    {
        // 使用info的加法运算符重载
        w[u] = w[u << 1] + w[u << 1 | 1];
    }

    // 区间查询
    info query(int u, int L, int R, int l, int r)
    {
        if ((l <= L) && (R <= r))
        {
            return w[u];
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            return query(u << 1, L, M, l, r) + query(u << 1 | 1, M + 1, R, l, r);
        }
        else
        {
            return info();
        }
    }
    void insert(int u, int L, int R, int p, const info &x)
    {
        if (L == R)
        {
            w[u] = x;
        }
        else
        {
            pushdown(u, L, R);
            int M = (L + R) >> 1;
            if (p <= M)
                insert(u << 1, L, M, p, x);
            else
                insert(u << 1 | 1, M + 1, R, p, x);
            pushup(u);
        }
    }
    void update(int u, int L, int R, int l, int r, const tag &x)
    {
        if ((l <= L) && (R <= r))
        {
            maketag(u, R - L + 1, x);
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            update(u << 1, L, M, l, r, x);
            update(u << 1 | 1, M + 1, R, l, r, x);
            pushup(u);
        }
    }

public:
    // 树链剖分操作
    void upd(int x, int y, LL z)
    {
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            update(1, 1, n, dfn[top[x]], dfn[x], z);
            x = fa[top[x]];
        }
        // 维护点权时这样写
        if (dep[x] > dep[y])
            swap(x, y);
        update(1, 1, n, dfn[x], dfn[y], z);
        // 维护边权时这样写
        //  if (x != y)
        //  {
        //      if (dep[x] > dep[y])
        //          swap(x, y);
        //      update(1, 1, n, dfn[x] + 1, dfn[y], z);
        //  }
    }

    LL qry(int x, int y)
    {
        info res = info();
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            res = res + query(1, 1, n, dfn[top[x]], dfn[x]);
            x = fa[top[x]];
        }
        // 维护点权时这样写：
        if (dep[x] > dep[y])
            swap(x, y);
        res = res + query(1, 1, n, dfn[x], dfn[y]);
        // 维护边权时这样写：
        //  if (x != y)
        //  {
        //      if (dep[x] > dep[y])
        //          swap(x, y);
        //      res = (res + query(1, 1, n, dfn[x] + 1, dfn[y])) % MOD;
        //  }
        return res.sum;
    }

    void updtree(int x, LL z)
    {
        update(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);
    }

    LL qrytree(int x)
    {
        return query(1, 1, n, dfn[x], dfn[x] + sz[x] - 1).sum;
    }
};
```
## 并查集（DSU）
```cpp
//警示后人：并查集一定要记得初始化！！！
(1)朴素并查集：
struct DSU//并查集范围[1,n]
{
    vector<int> f, sz;
    DSU(int n)
    {
        f.resize(n + 1);
        iota(f.begin(), f.end(), 0);
        sz.assign(n + 1, 0);
    }
    int find(int x)
    {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }
    bool same(int x, int y)
    {
        return find(x) == find(y);
    }
    bool merge(int x, int y)
    { // 把x合并到y的集合上
        x = find(x), y = find(y);
        if (x == y)
            return false;
        sz[y] += sz[x];
        f[x] = y;
        return true;
    }
    int cnt()
    {
        int res = 0;
        for (int i = 1; i < f.size(); i++)
            res += (f[i] == i);
        return res;
    }
    int size(int x)
    {
        return sz[find(x)];
    }
};
(3)维护到祖宗节点距离的并查集：
    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )// 初始化
    {
        p[i] = i;
        d[i] = 0;
    }
    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

## 拓扑排序
是DAG<——>有拓扑排序
常用于判断一个图是不是DAG
```cpp
vector<int> topsort(){//如果返回的数组大小不等于点的个数，说明不存在拓扑排序/该图有环/该图不是DAG
    vector<int>res;
    queue<int>Q;
    for(int i=1;i<=n;i++){
        if(!ind[i])Q.push(i);
    }
    while(!Q.empty()){
        int u=Q.front();
        Q.pop();
        res.push_back(u);
        for(int i=0;i<g[u].size();i++){
            int t=g[u][i];
            ind[t]--;
            if(!ind[t])Q.push(t);
        }
    }
    return res;
}
```
## 最短路
### 堆优化dijkstra--O(mlogn)
```cpp
struct edge{
    int to, cost;
};
vector<edge> g[N];   // vector模拟邻接表
int dist[N];         // 从起点走到这个点所需要的最短距离
bool st[N];          // 这个点是否已经确定
typedef pair<int, int> PII;
int dijkstra()
{
    // 初始化
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1}); // 存<距离，点>

    while (heap.size())
    {
        // 利用堆，找到距离最小的点
        auto t = heap.top(); // 堆顶的点就是距离最小的点
        heap.pop();
        int ver = t.second, distance = t.first; // 点，距离
        if (st[ver])
            continue;
        st[ver] = true;
        // 利用这个点来更新其它点
        for (int i = 0,sz=g[ver].size();i<sz;i++)
        { // 从更新的点走到下一个点
            int to = g[ver][i].to;
            int cost = g[ver][i].cost;
            if (dist[to] > distance + cost)
            {                              // 如果下一个点的原值不是最优
                dist[to] = distance + cost; // 更新下一个点
                heap.push({dist[to], to});   // 把更新的点加入到优先队列
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
```
### 朴素dijkstra--O(n2)
```cpp
int g[N][N];
int dist[N];
bool st[N];
int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 1; i <= n; i++){
        int t = -1;
        for (int j = 1; j <= n; j++) // 遍历所有点
            if (!st[j] && (t == -1 || dist[t] > dist[j]))//找到不在st中的最近点
                t = j;
        if(t==n)//可以不用写
            break;//剪枝优化
        st[t] = true;
        for (int j = 1; j <= n; j++)//用t点来更新其它点的距离
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
```
### Bellman-Ford
```cpp
const int N = 510, M = 10010;
int n, m, k;
int dist[N], backup[N];
struct Edge{
    int a, b, w;
} edges[M];
bool bellman_ford(){
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 0; i < k; i++){
        memcpy(backup, dist, sizeof(dist));//要用备份去更新
        for (int j = 0; j < m; j++){
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], backup[e.a] + e.w); // 用备份来更新，防止串联
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) return false;//因为存在负权边，所以不能直接判断dist[n]==0x3f3f3f3f
    else return true;
}

```
### SPFA
```cpp
const int N = 1000010;
int n, m;
struct edge{
    int to, cost;
};
vector<edge> g[N]; // vector模拟邻接表
int dist[N];       // 从起点走到这个点所需要的最短距离
bool st[N];        // 这个点是否已在队列内
int SPFA()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1]=0;
    queue<int>Q;
    Q.push(1);
    st[1] = true;
    while(!Q.empty()){
        int t=Q.front();
        Q.pop();
        st[t]=false;
        for(int i=0,sz=g[t].size();i<sz;i++){
            int j = g[t][i].to;
            int w = g[t][i].cost;
            if(dist[j]>dist[t]+w){
                dist[j] = dist[t] + w;
                if(!st[j]){
                    Q.push(j);
                    st[j] = false;
                }
            }
        }
    }
    if(dist[n]==0x3f3f3f3f)return false;
    else return true;

}
```
### Floyed
```cpp
const int N = 1000010;
int n, m;
struct edge{
    int to, cost;
};
vector<edge> g[N]; // vector模拟邻接表
int dist[N];       // 从起点走到这个点所需要的最短距离
bool st[N];        // 这个点是否已在队列内
int SPFA()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1]=0;
    queue<int>Q;
    Q.push(1);
    st[1] = true;
    while(!Q.empty()){
        int t=Q.front();
        Q.pop();
        st[t]=false;
        for(int i=0,sz=g[t].size();i<sz;i++){
            int j = g[t][i].to;
            int w = g[t][i].cost;
            if(dist[j]>dist[t]+w){
                dist[j] = dist[t] + w;
                if(!st[j]){
                    Q.push(j);
                    st[j] = false;
                }
            }
        }
    }
    if(dist[n]==0x3f3f3f3f)return false;
    else return true;

}
```
## 最小生成树
### Prim
```cpp
const int N = 510,INF=0x3f3f3f3f;
int g[N][N];//邻接矩阵存图
int dist[N];//每个点距离集合的距离
int n,m;
bool st[N];//记录点是不是在连通块内
int prim(){//如果存在最小生成树，则返回边权和，反之则返回INF
    memset(dist,0x3f,sizeof dist);
    int res = 0;//存的是最小生成树里面所有边的长度之和
    for(int i=0;i<n;i++){//循环n次，i没有意义
        int t = -1;
        for (int j = 1; j <= n;j++)//这个循环  结束后，t就是距离集合最近的点
            if(!st[j]&&(t==-1||dist[t]>dist[j]))t = j;
        if (i) res += dist[t]; // 更新距离和
        if(i&&dist[t]==INF)//说明这个图不连通
            return INF;
        for(int j=1;j<=n;j++) dist[j] = min(dist[j], g[j][t]);//更新其他点到集合的距离
        st[t] = true;//标记这个点已经加入连通块
    }
    return res;
}
```
### kruskal
```cpp
using namespace std;
const int N = 200010;
int n, m,pre[N];
struct Edge{
    int a, b, w;
    bool operator<(const Edge &W) const {
        return w < W.w;
    }
}edges[N];
int find(int x){
    return x == pre[x] ? x : (pre[x] = find(pre[x]));
}
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int a,b,w;
        cin>>a>>b>>w;
        edges[i] = {a, b, w};
    }
    sort(edges, edges + m);//将所有边排序
    for (int i = 1;i<=n;i++)pre[i]=i;//初始化并查集

    int res = 0, cnt = 0;
    for(int i=0;i<m;i++){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if(a!=b){
            res += w;//总边权++
            cnt++;//边的数量++
            pre[a] = b;
        }
    }
    if(cnt<n-1)puts("impossible");
    else
        cout << res;
    return 0;
}
```
## 二分图
### 染色法判定二分图
```cpp
const int N = 100010, M = 200010;
int n, m;
vector<int> g[N];
int color[N];
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = 0, sz = g[u].size(); i < sz; i++){ // 遍历跟这个点连接的所有点
        int j = g[u][i];
        if (!color[j]){ // 如果下一个点没有被染色
            if (!dfs(j, 3 - c))
                return false;
        }
        else if (color[j] == c) // 如果下一个点跟这个点颜色相同
            return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;
    while (m--){
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    bool flag = true;
    for (int i = 1; i <= n; i++)
        if (!color[i]) // 如果这个点，没有被染色
            if (!dfs(i, 1)){                 // 从这个点开始染色
                flag = false; // 如果发生矛盾
                break;
            }
    if (flag == true)
        puts("Yes");
    else
        puts("No");
    return 0;
}
```
### 匈牙利算法
```cpp
const int N = 510, M = 100010;
int n1, n2, m;
vector<int> g[N];
int match[N]; // 右边的点匹配的点
bool st[N];   // 判重
bool find(int x){
    for (int i = 0,sz=g[x].size(); i<sz; i++){ // 遍历能匹配的所有点
        int j = g[x][i];
        if (!st[j]){// 如果这个点没有找过
            st[j] = true;// 标记为找过
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
int main(){
    cin >> n1 >> n2 >> m;
    while (m--){
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }
    int res = 0;
    for (int i = 1; i <= n1; i++){
        memset(st, false, sizeof st);
        if (find(i))
            res++;
    }
    cout << res;
    return 0;
}
```

## 欧拉回路/欧拉路径
## 强连通分量
```cpp
//使用方法
vector<vector<int>>ans=tarjan(g).getscc();

class tarjan{
    int n;
    vector<vector<int>> g;
    vector<int> dfn;
    vector<int>low;
    vector<bool> ins;
    stack<int> stk;
    int tim;
    vector<vector<int>> sccs;
    void dfs(int u){
        dfn[u] = low[u] = ++tim;
        stk.push(u);
        ins[u] = true;
        for(int v:g[u]){
            if(!dfn[v]){//如果下一个点没有被访问过
                dfs(v);
                low[u] = min(low[u], low[v]);
            }
            else if(ins[v]){//如果下一个点在栈中
                low[u] = min(low[u], dfn[v]);
            }
        }
        if(dfn[u]==low[u]){
            vector<int> scc;
            while(true){
                int v = stk.top();
                stk.pop();
                ins[v] = false;
                scc.push_back(v);
                if(v==u)
                    break;
            }
            sccs.push_back(scc);
        }
    }
public:   
	tarjan(vector<vector<int>>_g):n(_g.size()-1),g(_g),dfn(n+1,0),low(n+1,0),ins(n+1,false),tim(0){};
    vector<vector<int>>getscc(){
        for(int i=1;i<=n;i++){
            if(!dfn[i])
                dfs(i);
        }
        return sccs;
    }
};
```