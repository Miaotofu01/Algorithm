# 基础算法
## 二分
### 左查找
```cpp
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;//mid向下取整
        if (check(mid)) r = mid;//如果mid满足答案区间的性质，左移r
        else l = mid + 1;//如果mid不满足答案区间的性质，右移l，l要跳过mid，所以+1
    }
    return l;
}
```
### 右查找
```cpp
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;//mid向上取整
        if (check(mid)) l = mid;//如果mid满足答案区间的性质，右移l
        else r = mid - 1;//如果mid不满足答案区间的性质，左移r，r要跳过mid
    }
    return l;
}
```
### 浮点数二分
```cpp
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```
## 前缀和与差分
### 一维前缀和
```cpp
s[i]=a[i]+s[i-1];//前缀和
s[r]-s[l-1]//[l,r]的区间和
```
### 一维差分
```cpp
b[i]=a[i]-a[i-1];//若a为前缀和数组，差分后则为原数组
b[l]+=c,b[r+1]-=c;//在区间[l,r]加c
```
### 二维前缀和
```cpp
//构建前缀和数组
for (int i=1; i<=n; i++)
	for (int j=1; j<=m; j++)
		s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
//求[x1,y1],[x2,y2]子矩阵和
sum=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
```
### 二维差分
```cpp
void insert(int x1,int y1,int x2,int y2,int c)
{     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
//构建差分数组
for(int i = 1;i <= n;i++)
    for(int j = 1;j <= m;j++)
        insert(i, j, i, j, a[i][j])；
//或者
b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i −1 ][j − 1]
```
## 高精度
```cpp
struct BigInt {
	const int N=1000;
    int a[N];
    BigInt(int x = 0) : a{} {
        for (int i = 0; x; i++) {
            a[i] = x % 10;
            x /= 10;
        }
    }
    BigInt &operator*=(int x) {
        for (int i = 0; i < N; i++) {
            a[i] *= x;
        }
        for (int i = 0; i < N - 1; i++) {
            a[i + 1] += a[i] / 10;
            a[i] %= 10;
        }
        return *this;
    }
    BigInt &operator/=(int x) {
        for (int i = N - 1; i >= 0; i--) {
            if (i) {
                a[i - 1] += a[i] % x * 10;
            }
            a[i] /= x;
        }
        return *this;
    }
    BigInt &operator+=(const BigInt &x) {
        for (int i = 0; i < N; i++) {
            a[i] += x.a[i];
            if (a[i] >= 10) {
                a[i + 1] += 1;
                a[i] -= 10;
            }
        }
        return *this;
    }
};
std::ostream &operator<<(std::ostream &o, const BigInt &a) {
    int t = N - 1;
    while (a.a[t] == 0) {
        t--;
    }
    for (int i = t; i >= 0; i--) {
        o << a.a[i];
    }
    return o;
}

```
## 离散化
版本1
```cpp
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int idx(int x){ // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
//或者
lower_bound(alls.begin(),alls.end(),x);
//或者用map映射储存映射值
```
版本2
```cpp
//数组版离散化
map<int,int>idx;//用来储存映射值
sort(b+1,b+1+btop);//排序
b[0] = -0x3f3f3f3f;//b数组用来暂存待离散化的值，离散化后b就没用了
for (int i = 1; i <= btop;i++){//去重
    if(b[i]!=b[i-1])
        alls[++top] = b[i], idx[b[i]] = top;
}
```
版本3
```cpp
//另一种离散化
void work(int a[]){//结果是直接将a数组转化为了离散化的数字
    for(int i=1;i<=n;i++)p[i]=i;//p是辅助数组
    sort(p + 1, p + 1 + n, [&](int x, int y)
         { return a[x] < a[y]; });//p存的是a中第i小的数的下标
    for(int i=1;i<=n;i++)
        a[p[i]] = i;
}
```
## 排序
### 归并排序
```cpp
void merge_sort(int q[], int l, int r)
{
	if(l>=r)return;
	int mid = r + l >> 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//左右两边都有序了
	int k = 0, i = l, j = mid + 1;
	while (i <= mid && j <= r)
		if (q[i] <= q[j])tmp[k++] = q[i++];
		else tmp[k++] = q[j++];
	while (i <= mid)tmp[k++] = q[i++];
	while (j <= r)tmp[k++] = q[j++];
	for (int i = l, j = 0; i <= r; i++, j++)q[i] = tmp[j];
}
```
### 快速排序
```cpp
void Qsort(int a[], int l, int r){
	int i = l, j = r, key = a[l + r>>1];
	do {
		while (a[i] < key)i++;
		while (a[j] > key)j--;
		if (i <= j)swap(&a[i++], &a[j--]);
	} while (i <= j);
	if (l < j)Qsort(a, l, j);
	if (i < r)Qsort(a, i, r);
}
```
## 快速读入
```cpp
#define rd read()
inline long long read()
{
	long long x=0,y=1;char c=getchar();//y代表正负（1.-1），最后乘上x就可以了。
	while (c<'0'||c>'9') {if (c=='-') y=-1;c=getchar();}//如果c是负号就把y赋为-1
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x*y;//乘起来输出
}
```