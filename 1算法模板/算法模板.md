# 面向竞赛框架（自用）
## 基础框架
支持：多组测试样例、快速读入（rd）、检查变量(debug())、检查容器(vdebug())、检查二进制(bit8())、以及LL PII 
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <climits>
#include <stack>
#include <unordered_map>
#include <queue>
#include <set>
#include <numeric>
#include <random>
#include <functional>
#include <bitset>
#include <cassert>
using namespace std;
#define debug(x) cout << #x << "=" << x << endl;
#define vdebug(a)         \
    cout << #a << "=";    \
    for (auto x : a)      \
        cout << x << " "; \
    cout << endl;
#define bin8(x) cout << #x << "=" << bitset<8>(x) << endl;
#define bin32(x) cout << #x << "=" << bitset<32>(x) << endl;
#define bin64(x) cout << #x << "=" << bitset<64>(x) << endl;

typedef long long LL;
typedef pair<int, int> PII;
typedef pair<int, pair<int, int>> PIII;
typedef pair<LL, LL> PIIL;
#define rd read()
inline LL read()
{
    LL x = 0, y = 1;
    char c = getchar();
    while (c > '9' || c < '0')
    {
        if (c == '-')
            y = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = x * 10 + c - '0', c = getchar();
    return x * y;
}
const int N = 2e6 + 5, INF = 0x3f3f3f3f;

inline void solve()
{

}
signed main()
{
    int T = 1;
    T = rd;
    while (T--)
    {
        solve();
    }
}
```
## 对拍器

```cpp
//======================  bat.cpp  ======================
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
void fread(string f)
{
    cout << f << ":\n";
    ifstream ifs;
    ifs.open(f, ios::in);
    string buf;
    while (getline(ifs, buf))
        cout <<"\t"<<buf << endl;
    ifs.close();
}
int main()
{
    int t = 0;
    while (true)
    {
        cout << "test: " << t++;
        system("generator.exe > data.in");
        system("std.exe < data.in >std.out");
        system("submit.exe < data.in >submit.out");

        if (system("fc std.out submit.out > diff.log"))
        {
            cout << " WA\n";
            fread("data.in");
            fread("std.out");
            fread("submit.out");
            break;
        }
        cout << " AC\n";
    }
    system("pause");
}
```

```cpp
//======================  generator.cpp  ======================
#include<random>
#include<iostream>
#include<ctime>
#include<algorithm>
#include<numeric>
#include <vector>
using namespace std;
static mt19937_64 rng(time(0));
int ra(int min=0,int max=1e9){//随机数生成器
    return std::uniform_int_distribution<int>(min, max)(rng);
}
const int MAXN = 10,MAXA = 200;
void gettree(){//生成随机树结构
    int n = ra(1, MAXN);
    cout << n << endl;
    vector<int>perm(n+1);
    iota(perm.begin(), perm.end(), 0);
    shuffle(perm.begin() + 1, perm.end(), rng);
    vector<int> g(n + 1);
    for(int i=2;i<=n;i++)
        g[i] = ra(1, i-1);
    for(int i=2;i<=n;i++)
        cout << perm[i] << " " << perm[g[i]] << endl;
}
void getarray(){//生成数组 -- q组区间查询
    int n = ra(1, MAXN);
    cout << n << endl;
    for (int i = 1; i <= n; i++)
    {
        cout << ra(1, MAXA) << " \n"[i == n];
    }
    int q = ra(1, n);
    cout << q << endl;
    while (q--)
    {
        int l = ra(1, n);
        int r = ra(l, n);
        cout << l << " " << r << endl;
    }
}
int main(){
    cout<<1<<endl;//多组测试用例
    gettree();
}
```

# 数学
## 随机数生成器
常用于异或哈希
```cpp
//#include<random>
static std::mt19937_64 rng(std::random_device{}());
//或者  static std::mt19937_64 rng(time(0));
int rand() {
	int min=0,max=1e9;
    return std::uniform_int_distribution<int>(min, max)(rng);
}
```
## 位运算
```cpp
template <typename T>
int bitsize(T x){//返回最高位1的次数
    return x == 0 ? -1 : bit_width(x)-1;
}
int lowbit(int x){//返回最低位的1
	return x&-x;
}

```
## 取整
```cpp
//对a/b取整
a/b //向下取整
(a+b-1)/b //向上取整
(a+b/2)/b //四舍五入
```
## 快速幂
```cpp
//不乘1LL见祖宗
int qpow(int m, int k)
{
    int res = 1 % mod, t = m;
    while (k)
    {
        if (k & 1)
            res = 1LL*res * t % mod;
        t = 1LL*t * t % mod;
        k >>= 1;
    }
    return res;
}
```
## 快速组合数/排列数（模运算）
对称性：$C_n^k=C_n^{k-1}$
递推式：$C_n^k+C_n^k-1=C_n+1^k$
系数和：$\sum_{i=0}^n C_n^i=2^n$

```cpp  
class Comb{
    vector<int> f;
    vector<int> g;
    const int mod =1e9+7;
    int qpow(int m, int k)
    {
        int res = 1 % mod, t = m;
        while (k)
        {
            if (k & 1)
                res = 1LL*res * t % mod;
            t = 1LL*t * t % mod;
            k >>= 1;
        }
        return res;
    }
public:
    Comb(int n) : f(n + 1), g(n + 1)
    {
        f[0]=1;
        for (int i = 1; i <= n; i++)
            f[i] = 1LL*f[i - 1] * i % mod;
        g[n]= qpow(f[n], mod - 2);
        for(int i=n;i;i--){
            g[i - 1] = 1LL * g[i] * i % mod;
        }
    }
    int C(int n, int m)
    {
        if (n < m || m < 0)
            return 0;
        return 1LL*f[n] * g[m]%mod * g[n - m] % mod;
    }
    int A(int n, int m)
    {
        if (n < m || m < 0)
            return 0;
        return f[n] * g[n - m] % mod;
    }
};
Comb cmb(10000);
```
## 质数判定

```cpp
bool isprime(int n){//O（sqrt(N)）
	if(n<2)return false;
	for(int i=2;i<=n/i;i++){
		if(n%i==0)return false;
	}
	return true;
}
```
## 分解质因数

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

## 欧拉筛
### 朴素欧拉筛
```cpp
class sieve{
	vector<bool>st;
	vector<int> primes;
	public:
	sieve(int n){
		st.assign(n + 1, false);
		for (int i = 2;i<=n;i++){
			if(!st[i])primes.push_back(i);
			for (int j = 0; primes[j] <= n / i;j++){
				st[primes[j] * i] = true;
				if(i%primes[j]==0)
					break;
				}
		}
	}
	int find(int x){//找到大于等于x的第一个质数
		return *lower_bound(primes.begin(), primes.end(),x);
	}
};
sieve sv(1e6);
```
### SPF欧拉筛（支持快速质因数分解`O(logn)`，快速质数判断`O(1)`)
```cpp
struct sieve
{
    vector<int> spf;    
    vector<int> primes; 
    int n;             
    sieve(int _n) : n(_n){
        spf.resize(n + 1, 0); 
        spf[1] = 1;
        for (int i = 2; i <= n; i++){
            if (spf[i] == 0){
                spf[i] = i; // 质数的最小质因子是它本身
                primes.push_back(i);
            }
            for (int p : primes){
                if (p > spf[i] || 1LL * i * p > n)
                    break;
                spf[i * p] = p; // 标记最小质因子
            }
        }
    }
    // 质因数分解O(logn)
    void divide(int n){
        while (n > 1){
            int p = spf[n], count = 0;
            while (spf[n] == p)
                count++, n /= p;
            // 在这里分解出了每一个质因数p^count
        }
    }
    bool isprime(int x){
	    return spf[x]==x;
    }
    int find(int x){//找到大于等于x的第一个质数
		return *lower_bound(primes.begin(), primes.end(),x);
	}
};
```
## 最大公约数 最小公倍数
```cpp
int gcd(int a,int b){//返回a和b的最大公约数 O(logn)
	return b ? gcd(b, a % b) : a;
}
int gcd(int a, int b)//位运算优化快速gcd
{
	if(b) while(b ^= a ^= b ^= a %= b);
	return a;
}
int lcm(int a, int b){
	return a / gcd(a, b)*b;//警示后人:先除再乘防止越界
}
```
## 拓展欧几里得算法
```cpp
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b % x;
    return d;
}
```
## 乘法逆元
```cpp
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b % x;
    return d;
}
int inv(int a,int m){
    int x,y;
    int g = exgcd(a, m, x, y);
    if(g!=1)
        return -1;
    else
        return (x % m + m) % m;
}
```
# 基础算法
## 二分
### 左查找
```cpp
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;//mid向下取整
        if (check(mid)) r = mid;//如果mid满足答案区间的性质，左移r
        else l = mid + 1;//如果mid不满足答案区间的性质，右移l，l要跳过mid，所以+1
    }
    return l;
}
```
### 右查找
```cpp
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;//mid向上取整
        if (check(mid)) l = mid;//如果mid满足答案区间的性质，右移l
        else r = mid - 1;//如果mid不满足答案区间的性质，左移r，r要跳过mid
    }
    return l;
}
```
### 浮点数二分
```cpp
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```
## 前缀和与差分
### 一维前缀和
```cpp
s[i]=a[i]+s[i-1];//前缀和
s[r]-s[l-1]//[l,r]的区间和
```
### 一维差分
```cpp
b[i]=a[i]-a[i-1];//若a为前缀和数组，差分后则为原数组
b[l]+=c,b[r+1]-=c;//在区间[l,r]加c
```
### 二维前缀和
```cpp
//构建前缀和数组
for (int i=1; i<=n; i++)
	for (int j=1; j<=m; j++)
		s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
//求[x1,y1],[x2,y2]子矩阵和
sum=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
```
### 二维差分
```cpp
void insert(int x1,int y1,int x2,int y2,int c)
{     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
//构建差分数组
for(int i = 1;i <= n;i++)
    for(int j = 1;j <= m;j++)
        insert(i, j, i, j, a[i][j])；
//或者
b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i −1 ][j − 1]
```
## 高精度
```cpp
struct BigInt {
	const int N=1000;
    int a[N];
    BigInt(int x = 0) : a{} {
        for (int i = 0; x; i++) {
            a[i] = x % 10;
            x /= 10;
        }
    }
    BigInt &operator*=(int x) {
        for (int i = 0; i < N; i++) {
            a[i] *= x;
        }
        for (int i = 0; i < N - 1; i++) {
            a[i + 1] += a[i] / 10;
            a[i] %= 10;
        }
        return *this;
    }
    BigInt &operator/=(int x) {
        for (int i = N - 1; i >= 0; i--) {
            if (i) {
                a[i - 1] += a[i] % x * 10;
            }
            a[i] /= x;
        }
        return *this;
    }
    BigInt &operator+=(const BigInt &x) {
        for (int i = 0; i < N; i++) {
            a[i] += x.a[i];
            if (a[i] >= 10) {
                a[i + 1] += 1;
                a[i] -= 10;
            }
        }
        return *this;
    }
};
std::ostream &operator<<(std::ostream &o, const BigInt &a) {
    int t = N - 1;
    while (a.a[t] == 0) {
        t--;
    }
    for (int i = t; i >= 0; i--) {
        o << a.a[i];
    }
    return o;
}

```
## 离散化
版本1
```cpp
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int idx(int x){ // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
//或者
lower_bound(alls.begin(),alls.end(),x);
//或者用map映射储存映射值
```
版本2
```cpp
//数组版离散化
map<int,int>idx;//用来储存映射值
sort(b+1,b+1+btop);//排序
b[0] = -0x3f3f3f3f;//b数组用来暂存待离散化的值，离散化后b就没用了
for (int i = 1; i <= btop;i++){//去重
    if(b[i]!=b[i-1])
        alls[++top] = b[i], idx[b[i]] = top;
}
```
版本3
```cpp
//另一种离散化
void work(int a[]){//结果是直接将a数组转化为了离散化的数字
    for(int i=1;i<=n;i++)p[i]=i;//p是辅助数组
    sort(p + 1, p + 1 + n, [&](int x, int y)
         { return a[x] < a[y]; });//p存的是a中第i小的数的下标
    for(int i=1;i<=n;i++)
        a[p[i]] = i;
}
```
## 排序
### 归并排序
```cpp
void merge_sort(int q[], int l, int r)
{
	if(l>=r)return;
	int mid = r + l >> 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//左右两边都有序了
	int k = 0, i = l, j = mid + 1;
	while (i <= mid && j <= r)
		if (q[i] <= q[j])tmp[k++] = q[i++];
		else tmp[k++] = q[j++];
	while (i <= mid)tmp[k++] = q[i++];
	while (j <= r)tmp[k++] = q[j++];
	for (int i = l, j = 0; i <= r; i++, j++)q[i] = tmp[j];
}
```
### 快速排序
```cpp
void Qsort(int a[], int l, int r){
	int i = l, j = r, key = a[l + r>>1];
	do {
		while (a[i] < key)i++;
		while (a[j] > key)j--;
		if (i <= j)swap(&a[i++], &a[j--]);
	} while (i <= j);
	if (l < j)Qsort(a, l, j);
	if (i < r)Qsort(a, i, r);
}
```
## 快速读入
```cpp
#define rd read()
inline long long read()
{
	long long x=0,y=1;char c=getchar();//y代表正负（1.-1），最后乘上x就可以了。
	while (c<'0'||c>'9') {if (c=='-') y=-1;c=getchar();}//如果c是负号就把y赋为-1
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x*y;//乘起来输出
}
```
# 数据结构
## 单调队列
```cpp
//双端队列
deque<int>q
for(int i=0;i<n;i++){//队列中存的是下标
	if(q.size()&&i-k+1>q.front())q.pop_front();//判断队头是否已经滑出窗口；
	while(q.size()&&a[q.back()]>=a[i])tt--;//维护队列单调性 如果队尾大于要入列的元素，弹出队尾//双端队列
	q.push_back(i);新元素入队
}
```
## 单调栈
```cpp
//找到每一个元素在入栈方向上第一个满足对该元素的单调条件的元素
stack<int> stk;
for(int i=0;i<n;i++){
	while(stk.size()&&a[stk.back()]>=a[i])stk.pop()//出栈 第一个小于等于a[stk.back()]的数是a[i]
	stk.push(i);//入栈//存的是下标
}
```
## 树状数组
* 数据需要具有==区间可加性与区间可减性==
* 树状数组作为桶使用时，可以统计`一个数组中，i前面比a[i]小的元素数量`
* 树状数组的优点在于其可修改性，把一个离线问题改变某些数据的排列方式就可以得到某种有序性，随即可以转化成在线问题，而求在这个在线过程中某些值的累积，可以通过树状数组求解
* 要实现区间修改+单点查询，就在a的差分数组上建树状数组
* 要实现区间修改+区间查询，用线段树即可
```cpp
template <typename T>
class Fenwick
{
    vector<T> c;
    int n;
public:
    Fenwick(int _n)//树状数组大小为[1,n]
    { // 用数组大小初始化
        n = _n;
        c.assign(n + 1, 0);
    }
    Fenwick(vector<T> &a) // 用数组初始化
    {
        n = a.size() - 1;
        vector<T> pre(n + 1, 0);
        c.assign(n + 1, 0);
        for (int i = 1; i <= n; i++)
        {
            pre[i] = pre[i - 1] + a[i];
            c[i] = pre[i] - pre[i - (i & -i)];
        }
    }
    T sum(int x)
    { // 求x位置的前缀和
        T res{};
        for (int i = x; i; i -= i & -i)
        {
            res += c[i];
        }
        return res;
    }
    void add(int x, const T &y)
    { // 在x位置上加上y
        for (int i = x; i <= n; i += i & -i)
            c[i] += y;
    }
    T range(int l, int r)
    { // 计算[l,r]的区间和
        return sum(r) - sum(l - 1);
    }
    int select(const T &k)//找到最大的下标x,使得sum(x)<=k,维护频次信息时，select(k)+1表示第k大的数，复杂度O(logn) 比在sum上二分O(log^2 n)更快,比对顶堆常数更小
    {
        int x = 0;
        T cur{};
        for (int i = 1 << __lg(n); i; i /= 2)
            if (x + i <= n && cur + c[x + i] <= k)
                x += i,cur+=c[x];
        return x;
    }
};
```

## ST表
要求RMQ的操作函数具有==区间可加性==，如min，max，gcd，位操作（&，^，|），修改操作函数的时候记得修改ans的初始值
初始化时间复杂度为`O(n*logn)`,查询的复杂度为`O(1)`

```cpp
class ST{
    vector<vector<int>> f;
    public:
    ST(const vector<int>& a){
        int n = a.size() - 1;
        f.assign(n + 1, vector<int>(int(log2(n)) + 2));
        for (int i = 1; i <= n; i++)
            f[i][0] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 1; i + (1 << j) - 1 <= n; i++)
                f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);//op
    }
    int RMQ(int l, int r)
    {
        int L = r - l + 1, ans = -0x3f3f3f3f;//op
        for (int i = 0, j = l; (1 << i) <= L; i++)
        {
            if ((L >> i) & 1)
            {
                ans = max(ans, f[j][i]);//op
                j += (1 << i);
            }
        }
        return ans;
    }
};
```
## 线段树
#### Info线段树
```cpp
// 自定义数据类型线段树
struct tag
{
    LL add = 0;
    tag(LL a = 0) : add(a) {}
};

struct info
{
    LL sum = 0;
    int len = 1; // 区间长度
    info() {}
    info(LL x) : sum(x) {}
    // 应用标记：区间加
    info apply(tag t, int new_len) const
    {
        info res = *this;
        res.sum += t.add * new_len; // 区间和更新
        return res;
    }
};
// 标记合并
tag operator+(const tag &a, const tag &b)
{
    return tag(a.add + b.add); // 加法合并
}
// 区间合并
info operator+(const info &a, const info &b)
{
    info res;
    res.sum = a.sum + b.sum;
    res.len = a.len + b.len; // 维护区间长度
    return res;
}
class stree
{
    vector<info> w;   // 存储区间信息
    vector<tag> lazy; // 存储延迟标记
    int n;
    // 应用标记到节点
    void maketag(int u, int len, const tag &t)
    {
        // 合并标记（需重载tag的+运算符）
        lazy[u] = lazy[u] + t;
        // 应用标记到区间信息（需实现info::apply方法）
        w[u] = w[u].apply(t, len);
    }

    // 标记下传
    void pushdown(int u, int L, int R)
    {
        if (lazy[u].add == 0)
            return;
        int M = (L + R) >> 1;
        maketag(u << 1, M - L + 1, lazy[u]); // 左子树
        maketag(u << 1 | 1, R - M, lazy[u]); // 右子树
        lazy[u] = tag();                     // 重置为空标记
    }
    // 合并子节点信息
    void pushup(int u)
    {
        w[u] = w[u << 1] + w[u << 1 | 1];
    }

    // 区间查询
    info query(int u, int L, int R, int l, int r)
    {
        if ((l <= L) && (R <= r))
        {
            return w[u];
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            return query(u << 1, L, M, l, r) + query(u << 1 | 1, M + 1, R, l, r);
        }
        else
        {
            return info(); // 返回空info（需默认构造函数）
        }
    }
    //单点修改（插入数据）
    void insert(int u, int L, int R, int p, const info &x)
    {
        if (L == R)
        {
            w[u] = x;
        }
        else
        {
            pushdown(u, L, R);
            int M = (L + R) >> 1;
            if (p <= M)
                insert(u << 1, L, M, p, x);
            else
                insert(u << 1 | 1, M + 1, R, p, x);
            pushup(u);
        }
    }
    //区间加
    void update(int u, int L, int R, int l, int r, const tag &x)
    {
        if ((l <= L) && (R <= r))
        {
            maketag(u, R - L + 1, x);
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            update(u << 1, L, M, l, r, x);
            update(u << 1 | 1, M + 1, R, l, r, x);
            pushup(u);
        }
    }

public:
    stree(int _n) : n(_n)
    {
        w.resize(4 * n + 1);
        lazy.resize(4 * n + 1);
    }
    // 单点查询接口
    info query(int p)
    {
        return query(1, 1, n, p,p);
    }
    // 区间查询接口
    info query(int l, int r)
    {
        return query(1, 1, n, l, r);
    }
    // 单点修改接口
    void insert(int p, const info &x)
    {
        insert(1, 1, n, p, x);
    }
    // 区间加法接口
    void update(int l, int r, const tag &x)
    {
        update(1, 1, n, l, r, x);
    }
};


```

## Tire字典树
```cpp
int son[N][26];//[N]结点的[26]儿子的下标
int cnt[N];//以[N]结尾的单词的数量
int idx;//树结点的编号
//下标是0的点，既是根结点，又是空结点
void insert(char str[]){
	int p=0;//当前在树的哪个位置
	for(int i=0;str[i];i++){
		int u = str[i]-'a';//映射
		if(!son[p][u])son[p][u]=++idx;//如果这个字母不在树上，创建结点
		p=son[p][u];//更新位置
	}
	cnt[p]++;
}
int query(char str[]){
	int p=0;
	for(int i=0;str[i];i++){
		int u=str[i]-'a';
		if(!son[p][u])return 0;
		p = son[p][u];
	}
	return cnt[p];
}
```
## KMP
```cpp
void get_Next(string s, int next[])	//这个函数对字符串s进行预处理得到next数组
{
	int j = 0;
	next[0] = 0;//初始化
	for(int i = 1; i<s.size(); i++){//i指针指向的是后缀末尾，j指针指向的是前缀末尾
		while(j>0&&s[i]!=s[j])	j = next[j-1];//前后缀不相同，去找j前一位的最长相等前后缀
		if(s[i]==s[j])	j++;//前后缀相同，j指针后移
		next[i] = j;//更新next数组
	}
}
int strSTR(string s, string t)	//是从s中找到t，如果存在返回t出现的位置，如果不存在返回-1
{
	if(t.size()==0)	return 0;
	get_Next(t, next);
	for(int i = 0,j = 0; i < s.size(); i++){
		while(j>0&&s[i]!= t[j])	j = next[j-1];	
		if(s[i]==t[j])	j++;
		if(j==t.size())	return i - t.size() + 1;
	}
	return -1;
}
```
# 图论
## 常见子问题
### 判断图的连通性
常用于判断欧拉路径的存在
```cpp
bool check(const vector<vector<int>> &g){
    vector<bool> st(g.size(), false);
    queue<int> q;
    st[1] = true;
    int cnt = 1;
    q.push(1);
    while (q.size())
    {
        int u = q.front();
        q.pop();
        for (int v : g[u])
        {
            if (!st[v])
            {
                st[v] = true;
                cnt++;
                q.push(v);
            }
        }
    }
    return cnt == g.size() - 1;
}
```
## 树论
### 树的直径
```cpp
    vector<int> dis(n + 1); // 根到所有点的距离
    vector<int> fa(n + 1);  // dfs路径中所有点的前继
    int far=0;//每次dfs中根能到达的最远的点
    function<void(int, int)> dfs = [&](int u, int f) mutable -> void
    {
        fa[u] = f;
        if(dis[u]>dis[far])
            far = u;
        for(PII ne:g[u]){
            int v = ne.first, w = ne.second;
            if(v==f)
                continue;
            dis[v] = dis[u] + w;
            dfs(v, u);
        }
    };
    dis[1] = 0;
    dfs(1, 0);
    int A=far;
    dis[A]=0;
    dfs(A, 0);
    int B = far;
```
### 树的重心
```cpp
    vector<int> f(n + 1);//f[u]保存u的最大子树的大小
    vector<int> size(n + 1);//size[u]表示u这个子树的大小
    int center = 0;//求解的重心
    f[0] = INF;
    function<void(int, int)> getcenter = [&](int u, int fa) mutable -> void
    {
        size[u] = 1, f[u] = 0;
        for (int v:g[u])
        {
            if(v==fa)
                continue;
            getcenter(v, u);
            size[u]+=size[v];
            f[u] = max(f[u], size[v]);
        }
        f[u] = max(f[u], n - size[u]);
        if (f[u] < f[center] || f[u] == f[center] && u < center)
            center = u;
    };
    getcenter(1,0);
```
### 最近公共祖先（LCA）
#### 倍增算法（在线算法$O(logn)$)
```cpp
    int nbit = __lg(n);
    vector<int> dep(n + 1);
    vector<vector<int>> anc(n + 1, vector<int>(nbit + 1));
    function<void(int, int)> dfs = [&](int u, int f) mutable -> void
    {
        anc[u][0] = f;
        dep[u] = dep[f] + 1;
        for (int v : g[u])
        {
            if (v == f)
                continue;
            dfs(v, u);
        }
    };
    dfs(root, 0);
    // init anc
    for (int j = 1; j <= nbit; j++)
        for (int i = 1; i <= n; i++)
            anc[i][j] = anc[anc[i][j - 1]][j - 1];
    // LCA
    function<int(int, int)> LCA = [&](int u, int v) mutable -> int
    {
        if (dep[u] < dep[v])
            swap(u, v);
        for (int i = nbit; i >= 0; i--)
            if (dep[anc[u][i]] >= dep[v])
                u = anc[u][i];
        if (u == v)
            return u;
        for (int i = nbit; i >= 0; i--)
            if (anc[u][i] != anc[v][i])
                u = anc[u][i], v = anc[v][i];
        return anc[u][0];
    };
```
#### tarjan算法（离线算法$O(n+m)$）
（暂空）
### 树链剖分/重链剖分
```cpp
// 使用方法：
// 初始化：addedge后init(root)，可以修改MOD，MOD默认为2e9
// 方法：
// void upd(int x, int y, LL z)在x到y的路径上所有点权+z
// LL qry(int x, int y) 查询x到y路径上的点权和
// void updtree(int x, LL z) 把x子树的点权+z
// LL qrytree(int x)查询x子树的点权
// int lca(int u, int v)树链LCA
struct tag
{
    LL add = 0;
    tag(LL a = 0) : add(a) {}
};

struct info
{
    LL sum = 0;
    int len = 1; // 区间长度
    info() {}
    info(LL x) : sum(x) {}
    // 应用标记：区间加
    info apply(tag t, int new_len) const
    {
        info res = *this;
        res.sum = (res.sum + t.add * new_len % MOD) % MOD; // 区间和更新
        return res;
    }
};
// 标记合并
tag operator+(const tag &a, const tag &b)
{
    return tag((a.add + b.add) % MOD); // 加法合并
}
// 区间合并
info operator+(const info &a, const info &b)
{
    info res;
    res.sum = (a.sum + b.sum) % MOD;
    res.len = a.len + b.len; // 维护区间长度
    return res;
}

class HLD
{
    int n;
    vector<int> fa, wc, sz, top, dfn, rdfn, dep;
    vector<info> w;// 线段树数组
    vector<tag> lazy; 
    vector<vector<int>> g;

    int cur;

public:
    vector<int> p; // 点权数组
    // 初始化部分
    HLD(int _n) : n(_n),
                  fa(n + 1), wc(n + 1), sz(n + 1), top(n + 1),
                  dfn(n + 1), rdfn(n + 1), dep(n + 1), g(n + 1),
                  p(n + 1), w(4 * (n + 1)), lazy(4 * (n + 1)), cur(0) {}

    void addedge(int u, int v)
    {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    void init(int root = 1)
    {
        dfs1(root, 0);
        dfs2(root, root);
        build(1, 1, n);
    }

private:
    void dfs1(int u, int f)
    {
        sz[u] = 1;
        fa[u] = f;
        dep[u] = dep[f] + 1;
        wc[u] = 0;
        for (int v : g[u])
        {
            if (v == f)
                continue;
            dfs1(v, u);
            sz[u] += sz[v];
            if (sz[v] > sz[wc[u]])
                wc[u] = v;
        }
    }

    void dfs2(int u, int TOP)
    {
        dfn[u] = ++cur;
        rdfn[cur] = u;
        top[u] = TOP;
        if (wc[u])
        {
            dfs2(wc[u], TOP);
            for (int v : g[u])
            {
                if (v == fa[u] || v == wc[u])
                    continue;
                dfs2(v, v);
            }
        }
    }

public:
    // 树链LCA
    int lca(int u, int v)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] > dep[top[v]])
            {
                u = fa[top[u]];
            }
            else
            {
                v = fa[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    // 线段树部分
private:
    void build(int u, int L, int R)
    {
        lazy[u] = tag();
        if (L == R)
        {
            w[u] = info()+info(p[rdfn[L]]);
            return;
        }
        int M = (L + R) >> 1;
        build(u * 2, L, M);
        build(u * 2 + 1, M + 1, R);
        pushup(u);
    }

    void maketag(int u, int len, const tag &t)
    {
        // 合并标记（需重载tag的+运算符）
        lazy[u] = lazy[u] + t;
        // 应用标记到区间信息（需实现info::apply方法）
        w[u] = w[u].apply(t, len);
    }

    // 标记下传
    void pushdown(int u, int L, int R)
    {
        // 空标记检查（需tag支持==比较）
        if (lazy[u].add == 0)
            return;
        int M = (L + R) >> 1;
        maketag(u << 1, M - L + 1, lazy[u]); // 左子树
        maketag(u << 1 | 1, R - M, lazy[u]); // 右子树
        lazy[u] = tag();                     // 重置为空标记
    }

    // 合并子节点信息
    void pushup(int u)
    {
        // 使用info的加法运算符重载
        w[u] = w[u << 1] + w[u << 1 | 1];
    }

    // 区间查询
    info query(int u, int L, int R, int l, int r)
    {
        if ((l <= L) && (R <= r))
        {
            return w[u];
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            return query(u << 1, L, M, l, r) + query(u << 1 | 1, M + 1, R, l, r);
        }
        else
        {
            return info();
        }
    }
    void insert(int u, int L, int R, int p, const info &x)
    {
        if (L == R)
        {
            w[u] = x;
        }
        else
        {
            pushdown(u, L, R);
            int M = (L + R) >> 1;
            if (p <= M)
                insert(u << 1, L, M, p, x);
            else
                insert(u << 1 | 1, M + 1, R, p, x);
            pushup(u);
        }
    }
    void update(int u, int L, int R, int l, int r, const tag &x)
    {
        if ((l <= L) && (R <= r))
        {
            maketag(u, R - L + 1, x);
        }
        else if (!((L > r) || (R < l)))
        {
            int M = (L + R) >> 1;
            pushdown(u, L, R);
            update(u << 1, L, M, l, r, x);
            update(u << 1 | 1, M + 1, R, l, r, x);
            pushup(u);
        }
    }

public:
    // 树链剖分操作
    void upd(int x, int y, LL z)
    {
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            update(1, 1, n, dfn[top[x]], dfn[x], z);
            x = fa[top[x]];
        }
        // 维护点权时这样写
        if (dep[x] > dep[y])
            swap(x, y);
        update(1, 1, n, dfn[x], dfn[y], z);
        // 维护边权时这样写
        //  if (x != y)
        //  {
        //      if (dep[x] > dep[y])
        //          swap(x, y);
        //      update(1, 1, n, dfn[x] + 1, dfn[y], z);
        //  }
    }

    LL qry(int x, int y)
    {
        info res = info();
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            res = res + query(1, 1, n, dfn[top[x]], dfn[x]);
            x = fa[top[x]];
        }
        // 维护点权时这样写：
        if (dep[x] > dep[y])
            swap(x, y);
        res = res + query(1, 1, n, dfn[x], dfn[y]);
        // 维护边权时这样写：
        //  if (x != y)
        //  {
        //      if (dep[x] > dep[y])
        //          swap(x, y);
        //      res = (res + query(1, 1, n, dfn[x] + 1, dfn[y])) % MOD;
        //  }
        return res.sum;
    }

    void updtree(int x, LL z)
    {
        update(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);
    }

    LL qrytree(int x)
    {
        return query(1, 1, n, dfn[x], dfn[x] + sz[x] - 1).sum;
    }
};
```
## 并查集（DSU）
```cpp
//警示后人：并查集一定要记得初始化！！！
(1)朴素并查集：
struct DSU//并查集范围[1,n]
{
    vector<int> f, sz;
    DSU(int n)
    {
        f.resize(n + 1);
        iota(f.begin(), f.end(), 0);
        sz.assign(n + 1, 0);
    }
    int find(int x)
    {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }
    bool same(int x, int y)
    {
        return find(x) == find(y);
    }
    bool merge(int x, int y)
    { // 把x合并到y的集合上
        x = find(x), y = find(y);
        if (x == y)
            return false;
        sz[y] += sz[x];
        f[x] = y;
        return true;
    }
    int cnt()//计算连通块的数量O(n)
    {
        int res = 0;
        for (int i = 1; i < f.size(); i++)
            res += (f[i] == i);
        return res;
    }
    int size(int x)
    {
        return sz[find(x)];
    }
};
(3)维护到祖宗节点距离的并查集：
    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )// 初始化
    {
        p[i] = i;
        d[i] = 0;
    }
    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

## 拓扑排序
是DAG<——>有拓扑排序
常用于判断一个图是不是DAG
```cpp
vector<int> topsort(){//如果返回的数组大小不等于点的个数，说明不存在拓扑排序/该图有环/该图不是DAG
    vector<int>res;
    queue<int>Q;
    for(int i=1;i<=n;i++){
        if(!ind[i])Q.push(i);
    }
    while(!Q.empty()){
        int u=Q.front();
        Q.pop();
        res.push_back(u);
        for(int i=0;i<g[u].size();i++){
            int t=g[u][i];
            ind[t]--;
            if(!ind[t])Q.push(t);
        }
    }
    return res;
}
```
## 最短路
### 堆优化dijkstra-- O(mlogn)
```cpp
function<vector<int>(int)> dijkstra = [&](int beg) mutable -> vector<int>{ // 返回以beg为起点的单源最短路
	vector<int> dis(n + 1, INT_MAX);
	vector<bool> st(n + 1);
	dis[beg] = 0;
	priority_queue<PII, vector<PII>, greater<PII>> q;
	q.push({0, beg});
	while (q.size()){
		int u = q.top().second, d = q.top().first;
		q.pop();
		if (st[u])
			continue;
		st[u] = true;
		for (PII ne : g[u]){
			int v = ne.first, w = ne.second;
			if (dis[v] > d + w){
				dis[v] = d + w;
				q.push({dis[v], v});
			}
		}
	}
	return dis;
};
```
次短路
```cpp
function<vector<int>(int)> dijkstra = [&](int beg) mutable -> vector<int>{
	vector<int> dis(n + 1, INT_MAX),dis2(n+1,INT_MAX);
	dis[beg] = 0;
	priority_queue<PII, vector<PII>, greater<PII>> q;
	q.push({0, beg});
	while (q.size()){
		int u = q.top().second, d = q.top().first;
		q.pop();
		if(d>dis2[u])
			continue;
		for (PII ne : g[u]){
			int v = ne.first, w = ne.second;
			if (dis[v] > d + w){
				dis2[v] = dis[v];
				dis[v] = d + w;
				q.push({dis[v], v});
			}
			if(dis2[v]>d+w&&dis[v]<d+w){
				dis2[v]=d+w;
				q.push({dis2[v], v});
			}
		}
	}
	return dis2;
};
```
### Bellman-Ford
```cpp
const int N = 510, M = 10010;
int n, m, k;
int dist[N], backup[N];
struct Edge{
    int a, b, w;
} edges[M];
bool bellman_ford(){
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 0; i < k; i++){
        memcpy(backup, dist, sizeof(dist));//要用备份去更新
        for (int j = 0; j < m; j++){
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], backup[e.a] + e.w); // 用备份来更新，防止串联
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) return false;//因为存在负权边，所以不能直接判断dist[n]==0x3f3f3f3f
    else return true;
}

```
### SPFA 差分约束系统
**常用于差分约束：最短路径给出的是每个变量在可行解中可能的最小值；要得到最大值，通常需要转化为最长路径问题或做额外处理。**

```cpp
function<vector<int>(int)> SPFA = [&](int beg) mutable -> vector<int>{//返回dist数组，若无解(差分约束无解，存在负环)返回空数组
	vector<int> dist(n + 1, INT_MAX);
	vector<bool> st(n + 1, false); // 记录节点是否在队列中
	vector<int> cnt(n + 1,0);
	dist[beg] = 0, st[beg] = true; // 初始节点标记为在队列中
	queue<int> q;
	q.push(beg);
	cnt[beg]++;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		st[u] = false; // 节点出队，标记为不在队列中
		for (auto &ne : g[u])
		{
			int v = ne.first, w = ne.second;
			if (dist[v] > dist[u] + w)
			{ // 松弛操作
				dist[v] = dist[u] + w;
				if (!st[v])
				{ // 如果v不在队列中
					q.push(v);
					st[v] = true; // 加入队列后标记为true
					cnt[v]++;
					if(cnt[v]>n+1)//如果有
						return vector<int>();
				}
			}
		}
	}
	return dist;
};
```
### Floyed
```cpp
const int N = 1000010;
int n, m;
struct edge{
    int to, cost;
};
vector<edge> g[N]; // vector模拟邻接表
int dist[N];       // 从起点走到这个点所需要的最短距离
bool st[N];        // 这个点是否已在队列内
int SPFA()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1]=0;
    queue<int>Q;
    Q.push(1);
    st[1] = true;
    while(!Q.empty()){
        int t=Q.front();
        Q.pop();
        st[t]=false;
        for(int i=0,sz=g[t].size();i<sz;i++){
            int j = g[t][i].to;
            int w = g[t][i].cost;
            if(dist[j]>dist[t]+w){
                dist[j] = dist[t] + w;
                if(!st[j]){
                    Q.push(j);
                    st[j] = false;
                }
            }
        }
    }
    if(dist[n]==0x3f3f3f3f)return false;
    else return true;

}
```
## 最小生成树
### Prim
```cpp
const int N = 510,INF=0x3f3f3f3f;
int g[N][N];//邻接矩阵存图
int dist[N];//每个点距离集合的距离
int n,m;
bool st[N];//记录点是不是在连通块内
int prim(){//如果存在最小生成树，则返回边权和，反之则返回INF
    memset(dist,0x3f,sizeof dist);
    int res = 0;//存的是最小生成树里面所有边的长度之和
    for(int i=0;i<n;i++){//循环n次，i没有意义
        int t = -1;
        for (int j = 1; j <= n;j++)//这个循环  结束后，t就是距离集合最近的点
            if(!st[j]&&(t==-1||dist[t]>dist[j]))t = j;
        if (i) res += dist[t]; // 更新距离和
        if(i&&dist[t]==INF)//说明这个图不连通
            return INF;
        for(int j=1;j<=n;j++) dist[j] = min(dist[j], g[j][t]);//更新其他点到集合的距离
        st[t] = true;//标记这个点已经加入连通块
    }
    return res;
}
```
### kruskal
```cpp
using namespace std;
const int N = 200010;
int n, m,pre[N];
struct Edge{
    int a, b, w;
    bool operator<(const Edge &W) const {
        return w < W.w;
    }
}edges[N];
int find(int x){
    return x == pre[x] ? x : (pre[x] = find(pre[x]));
}
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int a,b,w;
        cin>>a>>b>>w;
        edges[i] = {a, b, w};
    }
    sort(edges, edges + m);//将所有边排序
    for (int i = 1;i<=n;i++)pre[i]=i;//初始化并查集

    int res = 0, cnt = 0;
    for(int i=0;i<m;i++){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if(a!=b){
            res += w;//总边权++
            cnt++;//边的数量++
            pre[a] = b;
        }
    }
    if(cnt<n-1)puts("impossible");
    else
        cout << res;
    return 0;
}
```
## 二分图
### 染色法判定二分图
```cpp
const int N = 100010, M = 200010;
int n, m;
vector<int> g[N];
int color[N];
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = 0, sz = g[u].size(); i < sz; i++){ // 遍历跟这个点连接的所有点
        int j = g[u][i];
        if (!color[j]){ // 如果下一个点没有被染色
            if (!dfs(j, 3 - c))
                return false;
        }
        else if (color[j] == c) // 如果下一个点跟这个点颜色相同
            return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;
    while (m--){
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    bool flag = true;
    for (int i = 1; i <= n; i++)
        if (!color[i]) // 如果这个点，没有被染色
            if (!dfs(i, 1)){                 // 从这个点开始染色
                flag = false; // 如果发生矛盾
                break;
            }
    if (flag == true)
        puts("Yes");
    else
        puts("No");
    return 0;
}
```
### 匈牙利算法
```cpp
const int N = 510, M = 100010;
int n1, n2, m;
vector<int> g[N];
int match[N]; // 右边的点匹配的点
bool st[N];   // 判重
bool find(int x){
    for (int i = 0,sz=g[x].size(); i<sz; i++){ // 遍历能匹配的所有点
        int j = g[x][i];
        if (!st[j]){// 如果这个点没有找过
            st[j] = true;// 标记为找过
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
int main(){
    cin >> n1 >> n2 >> m;
    while (m--){
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }
    int res = 0;
    for (int i = 1; i <= n1; i++){
        memset(st, false, sizeof st);
        if (find(i))
            res++;
    }
    cout << res;
    return 0;
}
```

## 欧拉回路/欧拉路径
## 强连通分量
```cpp
//使用方法
vector<vector<int>>ans=tarjan(g).getscc();

class tarjan{
    int n;
    vector<vector<int>> g;
    vector<int> dfn;
    vector<int>low;
    vector<bool> ins;
    stack<int> stk;
    int tim;
    vector<vector<int>> sccs;
    void dfs(int u){
        dfn[u] = low[u] = ++tim;
        stk.push(u);
        ins[u] = true;
        for(int v:g[u]){
            if(!dfn[v]){//如果下一个点没有被访问过
                dfs(v);
                low[u] = min(low[u], low[v]);
            }
            else if(ins[v]){//如果下一个点在栈中
                low[u] = min(low[u], dfn[v]);
            }
        }
        if(dfn[u]==low[u]){
            vector<int> scc;
            while(true){
                int v = stk.top();
                stk.pop();
                ins[v] = false;
                scc.push_back(v);
                if(v==u)
                    break;
            }
            sccs.push_back(scc);
        }
    }
public:   
	tarjan(vector<vector<int>>_g):n(_g.size()-1),g(_g),dfn(n+1,0),low(n+1,0),ins(n+1,false),tim(0){};
    vector<vector<int>>getscc(){
        for(int i=1;i<=n;i++){
            if(!dfn[i])
                dfs(i);
        }
        return sccs;
    }
};
```
# 经典动态规划
## 背包问题
### 01背包
```cpp
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];
int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];
    return 0;
}
```
### 完全背包
```cpp
const int N = 1010;
int n,m;
int v[N], w[N];
int f[N];
int main(){
    cin>>n>>m;
    for (int i = 1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
        for (int j = v[i]; j <= m;j++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];
    return 0;
}
```
### 二进制优化多重背包
```cpp
inline void solve(){
    int n = rd, m = rd;
    int cnt = 0;
    for (int i = 1; i <= n; i++){
        int a=rd,b=rd,s=rd;
        int k = 1;
        while(k<=s){
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if(s>0){
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];

}
```
### 分组背包
```cpp
inline void solve()
{
    int n = rd, m = rd;
    for (int i = 1; i <= n; i++)
    {
        s[i] = rd;
        for (int j = 0; j < s[i]; j++)
            v[i][j] = rd, w[i][j] = rd;
    }
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 0; j--)
            for (int k = 0; k < s[i]; k++)
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
    cout << f[m];
}
```
## 子序列问题
### 最长公共子序列
```cpp
void solve()
{
    cin >> n >> m >> a >> b;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i - 1] == b[j - 1])
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    cout << f[n][m];
}
```
### 最长上升子序列
```cpp
int main(){
    int n;
    cin>>n;
    int a[N]={},q[N]={};
    for(int i=1;i<=n;i++)cin>>a[i];
    int len = 0;
    q[0]=-0x3f3f3f3f;
    for (int i = 1;i<=n;i++){
        int l=0,r=len;
        while(l<r){
            int mid=l+r+1>>1;
            if(q[mid]<a[i])l=mid;
            else r=mid-1;
        }
        len=max(len,r+1);
        q[r + 1] = a[i];
    }
    cout << len;
    return 0;
}
```